var searchIndex = {};
searchIndex["peel"] = {"doc":"# Dynamic parsing within trees ðŸŒ² ðŸŒ³ ðŸŒ´","items":[[3,"PeelResult","peel","General return type of the Peel traversals",null,null],[12,"result","","A vector of parser results",0,null],[12,"left_input","","The left input",0,null],[12,"error","","Possible error which occured during the parsing",0,null],[3,"Peel","","The main peeling structure",null,null],[12,"graph","","The memory arena of the tree",1,null],[12,"root","","The first node added will be the root",1,null],[12,"data","","Additional data for which can be shared accross the parsers",1,null],[0,"error","","Basic error handling mechanisms",null,null],[3,"PeelError","peel::error","Representation for an error of the library",null,null],[12,"code","","The error variant",2,null],[12,"description","","Additional description for the error",2,null],[12,"cause","","The cause for this error",2,null],[4,"ErrorType","","Error codes as indicator what happened",null,null],[13,"NoTreeRoot","","New nodes have to be added before traversing",3,null],[13,"NoParserSucceed","","The first parser already failed",3,null],[13,"Incomplete","","A parser got not enough data",3,null],[13,"Other","","The error originates from another error",3,null],[11,"new","","Create a new `PeelError`",2,{"inputs":[{"name":"errortype"},{"name":"str"}],"output":{"name":"self"}}],[11,"fmt","","",2,null],[11,"fmt","","",2,null],[11,"description","","",2,null],[11,"from","","",2,{"inputs":[{"name":"error"}],"output":{"name":"peelerror"}}],[11,"fmt","","",3,null],[11,"eq","","",3,null],[11,"ne","","",3,null],[0,"parser","peel","General parser descriptions and traits",null,null],[6,"Parser","peel::parser","The type which will be stored within the tree structure",null,null],[6,"ParserResult","","A generic parser result",null,null],[6,"ParserResultVec","","A collection of parser results",null,null],[8,"Parsable","","The parsing trait",null,null],[10,"parse","","Parse using nom and return the result",4,null],[0,"example","peel","Example parsers",null,null],[5,"peel_example","peel::example","Return a `Peel` instance for the example parsers",null,{"inputs":[],"output":{"name":"peel"}}],[0,"prelude","","Sensible defaults for the example parsers",null,null],[0,"fmt","peel::example::prelude","Utilities for formatting and printing `String`s",null,null],[5,"format","peel::example::prelude::fmt","The format function takes a precompiled format string and a list of\narguments, to return the resulting formatted string.",null,{"inputs":[{"name":"arguments"}],"output":{"name":"string"}}],[8,"Debug","","Format trait for the `?` character.",null,null],[10,"fmt","","Formats the value using the given formatter.",5,null],[8,"Binary","","Format trait for the `b` character.",null,null],[10,"fmt","","Formats the value using the given formatter.",6,null],[3,"Error","","The error type which is returned from formatting a message into a stream.",null,null],[3,"DebugStruct","","A struct to help with `fmt::Debug` implementations.",null,null],[8,"UpperHex","","Format trait for the `X` character.",null,null],[10,"fmt","","Formats the value using the given formatter.",7,null],[8,"Pointer","","Format trait for the `p` character.",null,null],[10,"fmt","","Formats the value using the given formatter.",8,null],[3,"DebugList","","A struct to help with `fmt::Debug` implementations.",null,null],[8,"Octal","","Format trait for the `o` character.",null,null],[10,"fmt","","Formats the value using the given formatter.",9,null],[8,"UpperExp","","Format trait for the `E` character.",null,null],[10,"fmt","","Formats the value using the given formatter.",10,null],[3,"DebugSet","","A struct to help with `fmt::Debug` implementations.",null,null],[6,"Result","","The type returned by formatter methods.",null,null],[8,"LowerHex","","Format trait for the `x` character.",null,null],[10,"fmt","","Formats the value using the given formatter.",11,null],[3,"DebugTuple","","A struct to help with `fmt::Debug` implementations.",null,null],[5,"write","","The `write` function takes an output stream, a precompiled format string,\nand a list of arguments. The arguments will be formatted according to the\nspecified format string into the output stream provided.",null,{"inputs":[{"name":"write"},{"name":"arguments"}],"output":{"name":"result"}}],[3,"Arguments","","This structure represents a safely precompiled version of a format string\nand its arguments. This cannot be generated at runtime because it cannot\nsafely be done so, so no constructors are given and the fields are private\nto prevent modification.",null,null],[8,"Write","","A collection of methods that are required to format a message into a stream.",null,null],[10,"write_str","","Writes a slice of bytes into this writer, returning whether the write\nsucceeded.",12,null],[11,"write_char","","Writes a `char` into this writer, returning whether the write succeeded.",12,null],[11,"write_fmt","","Glue for usage of the `write!` macro with implementors of this trait.",12,null],[8,"LowerExp","","Format trait for the `e` character.",null,null],[10,"fmt","","Formats the value using the given formatter.",13,null],[3,"DebugMap","","A struct to help with `fmt::Debug` implementations.",null,null],[8,"Display","","Format trait for an empty format, `{}`.",null,null],[10,"fmt","","Formats the value using the given formatter.",14,null],[3,"Formatter","","A struct to represent both where to emit formatting strings to and how they\nshould be formatted. A mutable version of this is passed to all formatting\ntraits.",null,null],[4,"IResult","peel::example::prelude","Holds the result of parsing functions",null,null],[13,"Done","","indicates a correct parsing, the first field containing the rest of the unparsed data, the second field contains the parsed data",15,null],[13,"Error","","contains a Err, an enum that can indicate an error code, a position in the input, and a pointer to another error, making a list of errors in the parsing tree",15,null],[13,"Incomplete","","Incomplete contains a Needed, an enum than can represent a known quantity of input data, or unknown",15,null],[3,"Parser1","","The first example parser",null,null],[3,"Parser1Result","","The result of the first example parser",null,null],[3,"Parser2","","The second example parser",null,null],[3,"Parser2Result","","The result of the second example parser",null,null],[3,"Parser3","","The third example parser",null,null],[3,"Parser3Result","","The result of the third example parser",null,null],[3,"Parser4","","The fourth example parser",null,null],[3,"Parser4Result","","The result of the fourth example parser",null,null],[0,"prelude","peel","Provides sensible imports at all",null,null],[11,"fmt","","",0,null],[11,"new","","Create a new empty `Peel` instance",1,{"inputs":[],"output":{"name":"self"}}],[11,"set_log_level","","Set the global log level for reporting",1,null],[11,"new_parser","","Create a new boxed Parser and return a corresponding Node",1,null],[11,"link","","Append the second node to the first one within the current tree structure",1,null],[11,"remove","","Remove a parser from the graph and return if existing.",1,null],[11,"link_nodes","","Link multiple nodes together",1,null],[11,"link_new_parser","","Create a new parser and link it with the provided node",1,null],[11,"traverse","","Convenient function for recursive traversal with the root as starting point",1,null],[11,"continue_traverse","","Continue the traversal from the last processed node. This can be useful if you want to\ncontinue traversal after an incomplete parsing.",1,null],[11,"create_dot_file","","Create a graphviz `graph.dot` file representation in the current directory",1,null],[11,"display_error","","Display an error from a parser",1,null],[11,"fmt","peel::example::prelude","",16,null],[11,"eq","","",16,null],[11,"parse","","The actual parsing entry point",17,null],[11,"fmt","","",17,null],[11,"fmt","","",18,null],[11,"eq","","",18,null],[11,"parse","","The actual parsing entry point",19,null],[11,"fmt","","",19,null],[11,"fmt","","",20,null],[11,"eq","","",20,null],[11,"parse","","The actual parsing entry point",21,null],[11,"fmt","","",21,null],[11,"fmt","","",22,null],[11,"eq","","",22,null],[11,"parse","","The actual parsing entry point",23,null],[11,"fmt","","",23,null],[11,"fmt","peel::example::prelude::fmt","",24,null],[11,"fmt","","",25,null],[11,"write_str","","",26,null],[11,"write_char","","",26,null],[11,"write_fmt","","",26,null],[11,"cmp","","",25,null],[11,"partial_cmp","","",25,null],[11,"eq","","",25,null],[11,"default","","",25,{"inputs":[],"output":{"name":"error"}}],[11,"clone","","",25,null],[11,"clone","","",24,null],[11,"fmt","","",24,null],[11,"fmt","","",25,null],[11,"hash","","",25,null],[11,"description","","",25,null],[11,"remaining_input","peel::example::prelude","",15,null],[11,"remaining_input","","",15,null],[11,"remaining_input","","",15,null],[11,"eq","","",15,null],[11,"ne","","",15,null],[11,"clone","","",15,null],[11,"fmt","","",15,null],[11,"output","","",15,null],[11,"output","","",15,null],[11,"output","","",15,null],[11,"field","peel::example::prelude::fmt","Adds a new field to the generated struct output.",27,null],[11,"finish","","Finishes output and returns any error encountered.",27,null],[11,"entry","","Adds a new entry to the list output.",28,null],[11,"entries","","Adds the contents of an iterator of entries to the list output.",28,null],[11,"finish","","Finishes output and returns any error encountered.",28,null],[11,"entry","","Adds a new entry to the set output.",29,null],[11,"entries","","Adds the contents of an iterator of entries to the set output.",29,null],[11,"finish","","Finishes output and returns any error encountered.",29,null],[11,"field","","Adds a new field to the generated tuple struct output.",30,null],[11,"finish","","Finishes output and returns any error encountered.",30,null],[11,"entry","","Adds a new entry to the map output.",31,null],[11,"entries","","Adds the contents of an iterator of entries to the map output.",31,null],[11,"finish","","Finishes output and returns any error encountered.",31,null],[11,"pad_integral","","Performs the correct padding for an integer which has already been\nemitted into a str. The str should *not* contain the sign for the\ninteger, that will be added by this method.",26,null],[11,"pad","","This function takes a string slice and emits it to the internal buffer\nafter applying the relevant formatting flags specified. The flags\nrecognized for generic strings are:",26,null],[11,"write_str","","Writes some data to the underlying buffer contained within this\nformatter.",26,null],[11,"write_fmt","","Writes some formatted information into this instance",26,null],[11,"flags","","Flags for formatting (packed version of rt::Flag)",26,null],[11,"fill","","Character used as &#39;fill&#39; whenever there is alignment",26,null],[11,"align","","Flag indicating what form of alignment was requested",26,null],[11,"width","","Optionally specified integer width that the output should be",26,null],[11,"precision","","Optionally specified precision for numeric types",26,null],[11,"sign_plus","","Determines if the `+` flag was specified.",26,null],[11,"sign_minus","","Determines if the `-` flag was specified.",26,null],[11,"alternate","","Determines if the `#` flag was specified.",26,null],[11,"sign_aware_zero_pad","","Determines if the `0` flag was specified.",26,null],[11,"debug_struct","","Creates a `DebugStruct` builder designed to assist with creation of\n`fmt::Debug` implementations for structs.",26,null],[11,"debug_tuple","","Creates a `DebugTuple` builder designed to assist with creation of\n`fmt::Debug` implementations for tuple structs.",26,null],[11,"debug_list","","Creates a `DebugList` builder designed to assist with creation of\n`fmt::Debug` implementations for list-like structures.",26,null],[11,"debug_set","","Creates a `DebugSet` builder designed to assist with creation of\n`fmt::Debug` implementations for set-like structures.",26,null],[11,"debug_map","","Creates a `DebugMap` builder designed to assist with creation of\n`fmt::Debug` implementations for map-like structures.",26,null],[11,"map_err","peel::example::prelude","Maps a `IResult&lt;I, O, E&gt;` to `IResult&lt;I, O, N&gt;` by appling a function\nto a contained `Error` value, leaving `Done` and `Incomplete` value\nuntouched.",15,null],[11,"unwrap_err","","Unwrap the contained `Error(I, E)` value, or panic if the `IResult` is not\n`Error`.",15,null],[11,"to_full_result","","Convert the IResult to a std::result::Result",15,null],[11,"to_result","","Convert the IResult to a std::result::Result",15,null],[11,"is_done","","",15,null],[11,"is_err","","",15,null],[11,"is_incomplete","","",15,null],[11,"map","","Maps a `IResult&lt;I, O, E&gt;` to `IResult&lt;I, N, E&gt;` by appling a function\nto a contained `Done` value, leaving `Error` and `Incomplete` value\nuntouched.",15,null],[11,"map_inc","","Maps a `IResult&lt;I, O, E&gt;` to `IResult&lt;I, O, E&gt;` by appling a function\nto a contained `Incomplete` value, leaving `Done` and `Error` value\nuntouched.",15,null],[11,"unwrap","","Unwrap the contained `Done(I, O)` value, or panic if the `IResult` is not\n`Done`.",15,null],[11,"unwrap_inc","","Unwrap the contained `Incomplete(n)` value, or panic if the `IResult` is not\n`Incomplete`.",15,null]],"paths":[[3,"PeelResult"],[3,"Peel"],[3,"PeelError"],[4,"ErrorType"],[8,"Parsable"],[8,"Debug"],[8,"Binary"],[8,"UpperHex"],[8,"Pointer"],[8,"Octal"],[8,"UpperExp"],[8,"LowerHex"],[8,"Write"],[8,"LowerExp"],[8,"Display"],[4,"IResult"],[3,"Parser1Result"],[3,"Parser1"],[3,"Parser2Result"],[3,"Parser2"],[3,"Parser3Result"],[3,"Parser3"],[3,"Parser4Result"],[3,"Parser4"],[3,"Arguments"],[3,"Error"],[3,"Formatter"],[3,"DebugStruct"],[3,"DebugList"],[3,"DebugSet"],[3,"DebugTuple"],[3,"DebugMap"]]};
initSearch(searchIndex);
